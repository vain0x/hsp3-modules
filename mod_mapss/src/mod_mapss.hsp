// str-str map

#ifndef included_mod_mapss_hsp
#define included_mod_mapss_hsp

#module m_mapss

#define vartype_str 2

#define true 1
#define false 0

// memory structure
// meta:
//      zero
//      magic_code
//      mem_len
//      mem_cap
//      entry_len
//      entry_cap
// entry[]:
//      key_hash
//      key_addr
//      value_addr
// vec[]:
//      len
//      cap
//      byte[]

#define s_magic_code_offset 4
#define s_mem_len_offset 8
#define s_mem_cap_offset 12
#define s_entry_len_offset 16
#define s_entry_cap_offset 20
#define s_meta_size 24

#define s_key_hash_offset 0
#define s_key_addr_offset 4
#define s_value_addr_offset 8
#define s_entry_size 12

#define s_vec_len_offset 0
#define s_vec_cap_offset 4
#define s_vec_data_offset 8

#const s_mem_min_size (s_meta_size + s_entry_size + s_vec_data_offset + 4)

#define s_magic_code 0x1ac3

#define ctype key_hash_addr(%1) (s_meta_size + s_entry_size * (%1) + s_key_hash_offset)

#define ctype key_addr_addr(%1) (s_meta_size + s_entry_size * (%1) + s_key_addr_offset)

#define ctype value_addr_addr(%1) (s_meta_size + s_entry_size * (%1) + s_value_addr_offset)

#define ctype vec_len_addr(%1) (s_vec_len_offset + (%1))
#define ctype vec_cap_addr(%1) (s_vec_cap_offset + (%1))
#define ctype vec_data_addr(%1) (s_vec_data_offset + (%1))

#deffunc mapss_init

	s_hash_base = (rnd(0x10000) << 16) | rnd(0x10000)
	return

#deffunc mapss_make var inner, int given_cap, int given_data_size, \
	local mem_size, local cap, local data_size

	// Ensure at least 1 entry to avoid div-by-zero.
	cap = limit(given_cap, 1)

	data_size = limit(given_data_size, 8)

	mem_size = (s_meta_size + s_entry_size * cap + data_size + 0x7) & 0x7ffffff0
	assert mem_size \ 8 == 0

	inner = ""
	memexpand inner, mem_size
	memset    inner, 0, mem_size

	// zero
	assert lpeek(inner, 0) == 0
	assert strlen(inner) == 0

	// No extra allocation by default.
	assert given_cap > 0 || mem_size <= 64

	lpoke inner, s_magic_code_offset, s_magic_code
	lpoke inner, s_mem_len_offset, s_meta_size + s_entry_size * cap
	lpoke inner, s_mem_cap_offset, mem_size

	lpoke inner, s_entry_cap_offset, cap
	return

// -----------------------------------------------
// get/set
// -----------------------------------------------

#defcfunc mapss_length var inner

	assert vartype(inner) == vartype_str
	return lpeek(inner, s_entry_len_offset)

#defcfunc mapss_cap var inner

	assert vartype(inner) == vartype_str
	return lpeek(inner, s_entry_cap_offset)

#defcfunc mapss_get_key_hash var inner, int entry_i

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	return lpeek(inner, key_hash_addr(entry_i))

#deffunc mapss_set_key_hash var inner, int entry_i, int key_hash

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	lpoke inner, key_hash_addr(entry_i), key_hash
	return

#defcfunc mapss_get_key_addr var inner, int entry_i, \
	local addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	addr = lpeek(inner, key_addr_addr(entry_i))
	assert addr != 0
	return addr

#deffunc mapss_set_key_addr var inner, int entry_i, int key_addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	lpoke inner, key_addr_addr(entry_i), key_addr
	return

#defcfunc mapss_get_key_len var inner, int entry_i, \
	local addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	addr = mapss_get_key_addr(inner, entry_i)
	return lpeek(inner, vec_len_addr(addr))

#deffunc mapss_set_key_len var inner, int entry_i, int key_len, \
	local addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	addr = mapss_get_key_addr(inner, entry_i)
	lpoke inner, vec_len_addr(addr), key_len
	return

#defcfunc mapss_get_key_cap var inner, int entry_i, \
	local addr

	addr = mapss_get_key_addr(inner, entry_i)
	return lpeek(inner, vec_cap_addr(addr))

#deffunc mapss_set_key_cap var inner, int entry_i, int key_cap, \
	local addr

	addr = mapss_get_key_addr(inner, entry_i)
	lpoke inner, vec_cap_addr(addr), key_cap
	return

#deffunc mapss_dup_key var inner, int entry_i, var value, \
	local addr

	addr = mapss_get_key_addr(inner, entry_i)
	mapss_dup_vec inner, addr, value
	return

#defcfunc mapss_entry_is_active var inner, int entry_i

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	return lpeek(inner, value_addr_addr(entry_i)) != 0

#defcfunc mapss_get_value_addr var inner, int entry_i, \
	local addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	addr = lpeek(inner, value_addr_addr(entry_i))
	assert addr != 0
	return addr

#deffunc mapss_set_value_addr var inner, int entry_i, int value_addr

	assert entry_i >= 0
	assert entry_i < mapss_cap(inner)
	lpoke inner, value_addr_addr(entry_i), value_addr
	return

#defcfunc mapss_get_value_len var inner, int entry_i, \
	local addr

	addr = mapss_get_value_addr(inner, entry_i)
	return lpeek(inner, vec_len_addr(addr))

#deffunc mapss_set_value_len var inner, int entry_i, int value_len, \
	local addr

	addr = mapss_get_value_addr(inner, entry_i)
	lpoke inner, vec_len_addr(addr), value_len
	return

#defcfunc mapss_get_value_cap var inner, int entry_i, \
	local addr

	addr = mapss_get_value_addr(inner, entry_i)
	return lpeek(inner, vec_cap_addr(addr))

#deffunc mapss_set_value_cap var inner, int entry_i, int value_cap, \
	local addr

	addr = mapss_get_value_addr(inner, entry_i)
	lpoke inner, vec_cap_addr(addr), value_cap
	return

#deffunc mapss_dup_value var inner, int entry_i, var value, \
	local addr

	addr = mapss_get_value_addr(inner, entry_i)
	mapss_dup_vec inner, addr, value
	return

#deffunc mapss_alloc_vec var inner, int cap, \
	local size, local addr, local mem_len, local mem_cap, local new_mem_cap

	assert cap > 0

	size = ((8 + cap) + 7) & 0x7ffffff0
	assert size \ 8 == 0
	assert size >= 8 + cap

	mem_len = lpeek(inner, s_mem_len_offset)
	mem_cap = lpeek(inner, s_mem_cap_offset)

	if mem_len + size > mem_cap {
		new_mem_cap = mem_cap + mem_cap / 2 + size + 64
		memexpand inner, new_mem_cap
		memset    inner, 0, new_mem_cap - mem_cap, mem_cap
		lpoke inner, s_mem_cap_offset, new_mem_cap
		mem_cap = new_mem_cap
	}

	addr = mem_len
	mem_len += size
	lpoke inner, s_mem_len_offset, mem_len

	lpoke inner, vec_len_addr(addr), 0
	lpoke inner, vec_cap_addr(addr), cap
	return addr

#deffunc mapss_dup_vec var inner, int addr, var value, \
	local cap

	assert addr >= s_meta_size + s_entry_size * mapss_cap(inner)
	assert addr < lpeek(inner, s_mem_cap_offset)
	if addr <= 0 {
		assert
		dupptr value, varptr(inner), 4, vartype_str
		return
	}

	cap = lpeek(inner, vec_cap_addr(addr))
	dupptr value, varptr(inner) + vec_data_addr(addr), cap, vartype_str
	return

#defcfunc mapss_is_empty var inner

	return mapss_length(inner) == 0

#defcfunc mapss_load_factor var inner

	return double(mapss_length(inner)) / mapss_cap(inner)

#defcfunc mapss_needs_rehashing var inner

	return mapss_load_factor(inner) >= 0.7

// -----------------------------------------------
// hash
// -----------------------------------------------

#defcfunc mapss_hash_key int key_len, var key_str, \
	local h

	h = s_hash_base ^ 17

	repeat key_len / 4
		h = ((h << 5) | (h >> 27)) ^ lpeek(key_str, cnt * 4)
	loop

	if key_len \ 4 == 3 {
		h = ((h << 5) | (h >> 27)) ^ wpeek(key_str, key_len - 3)
	}
	if key_len \ 4 == 2 {
		h = ((h << 5) | (h >> 27)) ^ wpeek(key_str, key_len - 2)
	}
	if key_len \ 2 == 1 {
		h = ((h << 5) | (h >> 27)) ^ peek(key_str, key_len - 1)
	}
	if h < 0 {
		h = -h
	}
	return h

// -----------------------------------------------
// lookup
// -----------------------------------------------

#deffunc mapss_do_lookup var inner, int key_hash, int key_len, var key_str, var entry_i, \
	local cap, local t, local ok

	cap = mapss_cap(inner)
	entry_i = key_hash - 1
	ok = false

	repeat cap
		entry_i = (entry_i + 1) \ cap

		if mapss_entry_is_active(inner, entry_i) == false {
			continue
		}

		if mapss_get_key_hash(inner, entry_i) != key_hash {
			continue
		}

		if mapss_get_key_len(inner, entry_i) != key_len {
			continue
		}

		mapss_dup_key inner, entry_i, t
		if t != key_str {
			continue
		}

		ok = true
		break
	loop

	if ok == false { // for debug
		entry_i = -1
	}
	return ok

#defcfunc mapss_has var inner, str key_str, \
	local key_hash, local key_len, local key_str_var, local entry_i

	key_str_var = key_str
	key_len = strlen(key_str_var)
	key_hash = mapss_hash_key(key_len, key_str_var)

	mapss_do_lookup inner, key_hash, key_len, key_str_var, entry_i
	return stat

#defcfunc mapss_get var inner, str key_str, \
	local key_hash, local key_len, local key_str_var, \
	local entry_i, local value

	key_str_var = key_str
	key_len = strlen(key_str_var)
	key_hash = mapss_hash_key(key_len, key_str_var)

	mapss_do_lookup inner, key_hash, key_len, key_str_var, entry_i
	if stat == false {
		return "" // default value
	}

	mapss_dup_value inner, entry_i, value
	return value

// -----------------------------------------------
// insert
// -----------------------------------------------

#deffunc mapss_do_insert var inner, \
	int key_hash, int key_len, var key_str, \
	int value_len, var value_str, \
	local cap, local entry_i, local t

	cap = mapss_cap(inner)
	entry_i = key_hash \ cap

	if mapss_entry_is_active(inner, entry_i) {
		// FIXME: locate
		return false
	}

	// alloc slot for key
	mapss_alloc_vec     inner, key_len + 1
	mapss_set_key_addr  inner, entry_i, stat
	mapss_set_key_hash  inner, entry_i, key_hash

	// write key data
	mapss_dup_key       inner, entry_i, t
	memcpy  t, key_str, key_len
	poke    t, key_len, 0
	mapss_set_key_len   inner, entry_i, key_len

	// alloc slot for value
	mapss_alloc_vec         inner, value_len + 1
	mapss_set_value_addr    inner, entry_i, stat

	// write value data
	mapss_dup_value     inner, entry_i, t
	memcpy  t, value_str, value_len
	poke    t, value_len, 0
	mapss_set_value_len inner, entry_i, value_len

	// increment count
	lpoke inner, s_entry_len_offset, mapss_length(inner) + 1
	return true

#deffunc mapss_insert var inner, str key_str, str value_str, \
	local key_hash, local key_len, local key_str_var, \
	local value_len, local value_str_var

	key_str_var = key_str
	key_len = strlen(key_str)
	key_hash = mapss_hash_key(key_len, key_str_var)

	value_str_var = value_str
	value_len = strlen(value_str_var)

	repeat
		mapss_do_insert inner, key_hash, key_len, key_str_var, value_len, value_str_var
		if stat {
			break
		}

		mapss_do_rehash inner
	loop
	return

// -----------------------------------------------
// rehash
// -----------------------------------------------

#deffunc mapss_clone var inner, var other, \
	local mem_cap

	mem_cap = lpeek(inner, s_mem_cap_offset)

	other = ""
	memexpand other, mem_cap
	memcpy    other, inner, mem_cap
	return

#deffunc mapss_do_rehash var inner, \
	local other, local cap, local ok, \
	local key_hash, local key_len, local key_str, \
	local value_len, local value_str

	repeat
		mapss_clone inner, other

		// Extend.
		cap = mapss_cap(inner)
		cap = limit(cap + cap / 2, 64)
		mapss_make inner, cap, lpeek(other, s_mem_cap_offset) // FIXME: calculate data size

		// Import.
		ok = true

		repeat mapss_cap(other)
			if mapss_entry_is_active(other, cnt) == false {
				continue
			}

			key_hash = mapss_get_key_hash(other, cnt)
			key_len = mapss_get_key_len(other, cnt)
			mapss_dup_key other, cnt, key_str

			value_len = mapss_get_value_len(other, cnt)
			mapss_dup_value other, cnt, value_str

			mapss_do_insert inner, key_hash, key_len, key_str, value_len, value_str
			if stat == false {
				ok = false
				break
			}
		loop

		if ok {
			break
		}
	loop
	assert mapss_length(inner) == mapss_length(other)
	return

#global

#endif
